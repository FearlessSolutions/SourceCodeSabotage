# Source Code Sabotage
Welcome to Source Code Sabotage.  Most programming challenge push you to make memory efficient and/or speed efficient code to solve a task such as inverting a binary tree, or iterating through a group of objects to create a new list. These challenes are not designed to make sure you code in an 0(N) standared or any other optimal Big O notation, but almost the opposite.
These challenges are meant to make you think what else can I add, what ways can I make code bigger as opposed to smaller.

As the challenges evolves so will the rules.  Some challenges might have specific rules attached to them but that is always subject to change.  There are a couple of basic rules.

1) The initial ask must always be done. 
2) All functions must be relevant to the ask.  An example would be if you were told to change the background color of a webpage when a button is clicked.  If you had a function that just returned a random number but didnt feed into the application then it is dead code, and thus completely unnecessary.  However if you had a function that retrieved a random number between 1-1000 then a function to check if it is between 0 and 255, then had it done three times to go into an RGB and that determines the final color, that would be perfect.
3)  Needs to work.  This exercise is meant to actually catch issues that could come up in code. Over-engineering can lead to bugs but we want our code to work.  So make it work.

Hope everyone has fun!